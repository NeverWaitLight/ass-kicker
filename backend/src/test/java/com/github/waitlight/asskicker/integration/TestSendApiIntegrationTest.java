package com.github.waitlight.asskicker.integration;

import com.github.waitlight.asskicker.repository.RegistrationLock;
import com.github.waitlight.asskicker.sender.MessageResponse;
import com.github.waitlight.asskicker.sender.Sender;
import com.github.waitlight.asskicker.sender.email.EmailSenderFactory;
import com.github.waitlight.asskicker.sender.email.EmailSenderProperty;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.reactive.AutoConfigureWebTestClient;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Primary;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.r2dbc.core.DatabaseClient;
import org.springframework.test.annotation.DirtiesContext;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.reactive.server.WebTestClient;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono;

import java.util.LinkedHashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,
        properties = {"app.test-send.max-requests=1"})
@ActiveProfiles("test")
@AutoConfigureWebTestClient
@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_EACH_TEST_METHOD)
class TestSendApiIntegrationTest {

    @Autowired
    private WebTestClient webTestClient;

    @Autowired
    private DatabaseClient databaseClient;

    @BeforeEach
    void setUp() {
        databaseClient.sql("DROP TABLE IF EXISTS t_user")
                .fetch()
                .rowsUpdated()
                .then()
                .block();
        databaseClient.sql("DROP TABLE IF EXISTS t_channel")
                .fetch()
                .rowsUpdated()
                .then()
                .block();
        databaseClient.sql("""
                CREATE TABLE t_user (
                    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    username VARCHAR(100) NOT NULL,
                    password_hash VARCHAR(255) NOT NULL,
                    role VARCHAR(20) NOT NULL,
                    status VARCHAR(20) NOT NULL,
                    created_at BIGINT NOT NULL,
                    updated_at BIGINT,
                    last_login_at BIGINT,
                    CONSTRAINT uk_t_user_username UNIQUE (username)
                )
                """)
                .fetch()
                .rowsUpdated()
                .then()
                .block();
    }

    @Test
    void testSendSuccess() {
        String token = registerAndLogin();

        Map<String, Object> body = new LinkedHashMap<>();
        body.put("type", "EMAIL");
        body.put("target", "test@example.com");
        body.put("content", "hello");
        body.put("properties", Map.of(
                "protocol", "SMTP",
                "smtp", Map.of(
                        "host", "smtp.example.com",
                        "port", "465",
                        "username", "user@example.com",
                        "password", "pass"
                )));

        webTestClient.post()
                .uri("/api/channels/test-send")
                .header(HttpHeaders.AUTHORIZATION, "Bearer " + token)
                .contentType(MediaType.APPLICATION_JSON)
                .bodyValue(body)
                .exchange()
                .expectStatus().isOk()
                .expectBody()
                .jsonPath("$.success").isEqualTo(true)
                .jsonPath("$.messageId").isEqualTo("test-id");
    }

    @Test
    void testSendRequiresAuth() {
        Map<String, Object> body = Map.of(
                "type", "EMAIL",
                "target", "test@example.com",
                "content", "hello",
                "properties", Map.of(
                        "protocol", "SMTP",
                        "smtp", Map.of(
                                "host", "smtp.example.com",
                                "port", "465",
                                "username", "user@example.com",
                                "password", "pass"
                        ))
        );

        webTestClient.post()
                .uri("/api/channels/test-send")
                .contentType(MediaType.APPLICATION_JSON)
                .bodyValue(body)
                .exchange()
                .expectStatus().isUnauthorized();
    }

    @Test
    void testSendRateLimited() {
        String token = registerAndLogin();

        Map<String, Object> body = Map.of(
                "type", "EMAIL",
                "target", "test@example.com",
                "content", "hello",
                "properties", Map.of(
                        "protocol", "SMTP",
                        "smtp", Map.of(
                                "host", "smtp.example.com",
                                "port", "465",
                                "username", "user@example.com",
                                "password", "pass"
                        ))
        );

        webTestClient.post()
                .uri("/api/channels/test-send")
                .header(HttpHeaders.AUTHORIZATION, "Bearer " + token)
                .contentType(MediaType.APPLICATION_JSON)
                .bodyValue(body)
                .exchange()
                .expectStatus().isOk();

        webTestClient.post()
                .uri("/api/channels/test-send")
                .header(HttpHeaders.AUTHORIZATION, "Bearer " + token)
                .contentType(MediaType.APPLICATION_JSON)
                .bodyValue(body)
                .exchange()
                .expectStatus().isEqualTo(429)
                .expectBody(String.class)
                .value(message -> assertEquals("测试发送过于频繁，请稍后再试", message));
    }

    @Test
    void testSendRejectsMissingSmtpConfig() {
        String token = registerAndLogin();

        Map<String, Object> body = Map.of(
                "type", "EMAIL",
                "target", "test@example.com",
                "content", "hello",
                "properties", Map.of(
                        "protocol", "SMTP",
                        "smtp", Map.of(
                                "host", "",
                                "port", "465",
                                "username", "user@example.com",
                                "password", "pass"
                        ))
        );

        webTestClient.post()
                .uri("/api/channels/test-send")
                .header(HttpHeaders.AUTHORIZATION, "Bearer " + token)
                .contentType(MediaType.APPLICATION_JSON)
                .bodyValue(body)
                .exchange()
                .expectStatus().isBadRequest()
                .expectBody(String.class)
                .value(message -> assertEquals("SMTP 主机不能为空", message));
    }

    private String registerAndLogin() {
        webTestClient.post()
                .uri("/api/auth/register")
                .contentType(MediaType.APPLICATION_JSON)
                .bodyValue(Map.of("username", "admin", "password", "pass"))
                .exchange()
                .expectStatus().isOk();

        Map<String, Object> tokenResponse = webTestClient.post()
                .uri("/api/auth/login")
                .contentType(MediaType.APPLICATION_JSON)
                .bodyValue(Map.of("username", "admin", "password", "pass"))
                .exchange()
                .expectStatus().isOk()
                .expectBody(Map.class)
                .returnResult()
                .getResponseBody();

        assertNotNull(tokenResponse);
        Object accessToken = tokenResponse.get("accessToken");
        assertNotNull(accessToken);
        return accessToken.toString();
    }

    @TestConfiguration
    static class TestConfig {
        @Bean
        @Primary
        RegistrationLock registrationLock() {
            return () -> Mono.empty();
        }

        @Bean
        @Primary
        EmailSenderFactory emailSenderFactory() {
            return new EmailSenderFactory(WebClient.builder()) {
                @Override
                public Sender create(EmailSenderProperty property) {
                    return new Sender() {
                        @Override
                        public MessageResponse send(com.github.waitlight.asskicker.sender.MessageRequest request) {
                            return MessageResponse.success("test-id");
                        }

                        @Override
                        public com.github.waitlight.asskicker.sender.SenderProperty getProperty() {
                            return property;
                        }
                    };
                }
            };
        }
    }
}
